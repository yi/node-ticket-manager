// Generated by CoffeeScript 1.7.1
(function() {
  var EMPTY_OBJ, MIN_FIELD_SELECTION, STATUS, Schema, TicketSchema, mongoose, paginator, schemaOptions, schemaStructure, timestamps, _;

  mongoose = require("mongoose");

  Schema = mongoose.Schema;

  _ = require('underscore');

  timestamps = require("mongoose-times");

  paginator = require('mongoose-paginator');

  STATUS = require("../enums/ticket_status");

  EMPTY_OBJ = {};

  MIN_FIELD_SELECTION = {
    select: 'id'
  };

  schemaStructure = {
    title: String,
    owner_id: String,
    attempts: {
      type: Number,
      "default": 0
    },
    category: String,
    status: {
      type: String,
      "default": STATUS.PENDING
    },
    content: Schema.Types.Mixed,
    comments: [
      {
        name: String,
        kind: String,
        content: String,
        date: Date
      }
    ],
    token: {
      type: String,
      trim: true,
      index: true
    }
  };

  schemaOptions = {};

  TicketSchema = new Schema(schemaStructure, schemaOptions);

  TicketSchema.plugin(timestamps, {
    created: "created_at",
    lastUpdated: "updated_at"
  });

  TicketSchema.plugin(paginator, {
    limit: 10,
    defaultKey: '_id',
    direction: 'desc'
  });

  TicketSchema.path('title').validate(function(val) {
    return val.length;
  }, 'Title cannot be blank');

  TicketSchema.path('category').validate(function(val) {
    return val.length;
  }, 'Category cannot be blank');

  TicketSchema.path('content').validate(function(val) {
    return val != null;
  }, 'content cannot be blank');

  TicketSchema.path('owner_id').validate(function(val) {
    return val.length;
  }, 'Owner id cannot be blank');

  TicketSchema.pre('save', function(next) {
    var query, theTitle;
    if (!this.isNew) {
      return next();
    }
    query = {
      $and: [
        {
          title: this.title
        }, {
          status: {
            $not: new RegExp("(" + STATUS.COMPLETE + "|" + STATUS.ABANDON + ")")
          }
        }
      ]
    };
    theTitle = this.title;
    mongoose.model('Ticket').findOne(query, 'title', function(err, ticket) {
      if (err != null) {
        return next(err);
      }
      if (ticket != null) {
        return next(new Error("ticket " + theTitle + " already exist"));
      }
      next();
    });
  });

  TicketSchema.statics.changeStatus = function(query, status, callback) {
    var update, where;
    console.log("[ticket::changeStatus] ");
    if (!STATUS.isValid(status)) {
      return callback(new Error("invalid status:" + status));
    }
    where = [];
    if (query.title != null) {
      where.push({
        title: query.title
      });
    } else if (query.id != null) {
      where.push({
        _id: query.id
      });
    } else {
      return callback(new Error("bad query, missing id neither title"));
    }
    update = {
      status: status,
      updated_at: Date.now()
    };
    switch (status) {
      case STATUS.COMPLETE:
        where.push({
          status: {
            $ne: STATUS.ABANDON
          }
        });
        update["$unset"] = {
          "token": ""
        };
        break;
      case STATUS.ABANDON:
        where.push({
          status: {
            $ne: STATUS.COMPLETE
          }
        });
        update["$unset"] = {
          "token": ""
        };
        break;
      case STATUS.PROCESSING:
        where.push({
          status: STATUS.PENDING
        });
    }
    this.findOneAndUpdate({
      $and: where
    }, update, (function(_this) {
      return function(err, ticket) {
        var comment;
        console.log("[ticket] err:" + err + ", ticket:%j", ticket);
        if (err != null) {
          return callback(err);
        }
        if (ticket == null) {
          return callback(new Error("missing ticket for query: " + (JSON.stringify(query))));
        }
        comment = {
          name: query.worker || query.whoami || query.name || "system",
          kind: "primary",
          content: "change ticket status to " + status
        };
        _this.addComment(ticket.id, comment, callback);
      };
    })(this));
  };

  TicketSchema.statics.addComment = function(id, comment, callback) {
    var update;
    if (!((id != null) && (comment.name != null) && (comment.kind != null) && (comment.content != null) && (callback != null))) {
      return callback(new Error("missing arrgument. id:" + id + ", name:" + comment.name + ", kind:" + comment.kind + ", content:" + comment.content + ", callback:" + callback));
    }
    console.log("[ticket::addComment] id:%j", id);
    comment.date = Date.now();
    update = {
      $push: {
        comments: comment
      },
      $set: {
        updated_at: Date.now()
      }
    };
    this.findByIdAndUpdate(id, update, callback);
  };

  TicketSchema.statics.list = function(status, after, callback) {
    var where;
    where = [];
    if (STATUS.isValid(status)) {
      where.push({
        status: status
      });
    }
    if (after != null) {
      where.push({
        after: after
      });
    }
    where = {
      $and: where
    };
    return this.paginate(where, '_id').execPagination(callback);
  };

  TicketSchema.statics.arrangeAssignment = function(options, callback) {
    var category, query, worker;
    options || (options = EMPTY_OBJ);
    worker = String(options.worker || options.name || "");
    category = String(options.category || "");
    if (!(worker && category)) {
      return callback(new Error("missing request params, worker:" + worker + ", category:" + category));
    }
    query = {
      $and: [
        {
          category: category
        }, {
          status: STATUS.PENDING
        }
      ]
    };
    this.findOne(query).sort({
      updated_at: 'asc'
    }).exec((function(_this) {
      return function(err, ticket) {
        if (err != null) {
          return callback(err);
        }
        if (ticket == null) {
          return callback();
        }
        options.id = ticket.id;
        _this.changeStatus(options, STATUS.PROCESSING, callback);
      };
    })(this));
  };

  TicketSchema.statics.removeByStatus = function(status, callback) {
    this.remove({
      status: status
    }, callback);
  };

  mongoose.model('Ticket', TicketSchema);

}).call(this);
